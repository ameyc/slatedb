From 8652ae346c76c712438e0864a01faa75c8cf1cb6 Mon Sep 17 00:00:00 2001
From: Amey Chaugule <amey@probablynothinglabs.xyz>
Date: Tue, 8 Oct 2024 12:52:01 -0700
Subject: [PATCH] Adding display for DBOptions and debug statements

---
 src/config.rs         | 121 +++++++++++++++++++++++++++++++++++++++++-
 src/manifest_store.rs |  11 +++-
 2 files changed, 130 insertions(+), 2 deletions(-)

diff --git a/src/config.rs b/src/config.rs
index 74dd22c..a40a80b 100644
--- a/src/config.rs
+++ b/src/config.rs
@@ -1,3 +1,4 @@
+use std::fmt::{self, Display, Formatter};
 use std::sync::Arc;
 use std::{str::FromStr, time::Duration};
 
@@ -327,7 +328,7 @@ impl Default for GarbageCollectorDirectoryOptions {
 }
 
 /// Garbage collector options for a directory.
-#[derive(Clone, Copy)]
+#[derive(Clone, Copy, Debug)]
 pub struct GarbageCollectorDirectoryOptions {
     /// The interval at which the garbage collector checks for files to garbage collect.
     pub poll_interval: Duration,
@@ -379,3 +380,121 @@ impl Default for ObjectStoreCacheOptions {
         }
     }
 }
+
+impl Display for DbOptions {
+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
+        writeln!(f, "DbOptions {{")?;
+        writeln!(f, "    flush_interval: {:?},", self.flush_interval)?;
+
+        #[cfg(feature = "wal_disable")]
+        writeln!(f, "    wal_enabled: {},", self.wal_enabled)?;
+
+        writeln!(
+            f,
+            "    manifest_poll_interval: {:?},",
+            self.manifest_poll_interval
+        )?;
+        writeln!(f, "    min_filter_keys: {},", self.min_filter_keys)?;
+        writeln!(f, "    filter_bits_per_key: {},", self.filter_bits_per_key)?;
+        writeln!(f, "    l0_sst_size_bytes: {},", self.l0_sst_size_bytes)?;
+        writeln!(f, "    l0_max_ssts: {},", self.l0_max_ssts)?;
+        writeln!(
+            f,
+            "    max_unflushed_memtable: {},",
+            self.max_unflushed_memtable
+        )?;
+
+        writeln!(
+            f,
+            "    compactor_options: {}",
+            match &self.compactor_options {
+                Some(opts) => format!("{}", CompactorOptionsDisplay(opts)),
+                None => "None".to_string(),
+            }
+        )?;
+
+        writeln!(
+            f,
+            "    compression_codec: {}",
+            match &self.compression_codec {
+                Some(codec) => format!("{:?}", codec),
+                None => "None".to_string(),
+            }
+        )?;
+
+        writeln!(
+            f,
+            "    object_store_cache_options: {}",
+            ObjectStoreCacheOptionsDisplay(&self.object_store_cache_options)
+        )?;
+
+        writeln!(
+            f,
+            "    block_cache: {}",
+            if self.block_cache.is_some() {
+                "Some(Arc<dyn DbCache>)"
+            } else {
+                "None"
+            }
+        )?;
+
+        writeln!(
+            f,
+            "    garbage_collector_options: {}",
+            match &self.garbage_collector_options {
+                Some(opts) => format!("{}", GarbageCollectorOptionsDisplay(opts)),
+                None => "None".to_string(),
+            }
+        )?;
+
+        write!(f, "}}")
+    }
+}
+
+// Helper structs for formatting complex types
+struct CompactorOptionsDisplay<'a>(&'a CompactorOptions);
+struct ObjectStoreCacheOptionsDisplay<'a>(&'a ObjectStoreCacheOptions);
+struct GarbageCollectorOptionsDisplay<'a>(&'a GarbageCollectorOptions);
+
+impl<'a> Display for CompactorOptionsDisplay<'a> {
+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
+        write!(f, "CompactorOptions {{ poll_interval: {:?}, max_sst_size: {}, max_concurrent_compactions: {}, compaction_runtime: {} }}",
+            self.0.poll_interval,
+            self.0.max_sst_size,
+            self.0.max_concurrent_compactions,
+            if self.0.compaction_runtime.is_some() { "Some(Handle)" } else { "None" }
+        )
+    }
+}
+
+impl<'a> Display for ObjectStoreCacheOptionsDisplay<'a> {
+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
+        write!(
+            f,
+            "ObjectStoreCacheOptions {{ root_folder: {:?}, part_size_bytes: {} }}",
+            self.0.root_folder, self.0.part_size_bytes
+        )
+    }
+}
+
+impl<'a> Display for GarbageCollectorOptionsDisplay<'a> {
+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
+        write!(f, "GarbageCollectorOptions {{ manifest_options: {:?}, wal_options: {:?}, compacted_options: {:?}, gc_runtime: {} }}",
+            self.0.manifest_options,
+            self.0.wal_options,
+            self.0.compacted_options,
+            if self.0.gc_runtime.is_some() { "Some(Handle)" } else { "None" }
+        )
+    }
+}
+
+// Implement Display for GarbageCollectorDirectoryOptions
+impl Display for GarbageCollectorDirectoryOptions {
+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
+        write!(
+            f,
+            "GarbageCollectorDirectoryOptions {{ poll_interval: {:?}, min_age: {:?} }}",
+            self.poll_interval, self.min_age
+        )
+    }
+}
diff --git a/src/manifest_store.rs b/src/manifest_store.rs
index 6d79f15..0ecd610 100644
--- a/src/manifest_store.rs
+++ b/src/manifest_store.rs
@@ -3,6 +3,7 @@ use std::sync::Arc;
 
 use chrono::Utc;
 use futures::StreamExt;
+use log::debug;
 use object_store::path::Path;
 use object_store::Error::AlreadyExists;
 use object_store::{Error, ObjectStore};
@@ -246,10 +247,13 @@ impl ManifestStore {
         &self,
         id_range: R,
     ) -> Result<Vec<ManifestFileMetadata>, SlateDBError> {
+        debug!("entered list_manifests");
         let manifest_path = &Path::from("/");
         let mut files_stream = self.object_store.list(Some(manifest_path));
         let mut manifests = Vec::new();
 
+        debug!("about to parse manifest files");
+
         while let Some(file) = match files_stream.next().await.transpose() {
             Ok(file) => file,
             Err(e) => return Err(SlateDBError::ObjectStoreError(e)),
@@ -264,9 +268,12 @@ impl ManifestStore {
                     });
                 }
                 Err(_) => warn!("Unknown file in manifest directory: {:?}", file.location),
-                _ => {}
+                _ => {
+                    debug!("hit an unknown state")
+                }
             }
         }
+        debug!("manifests successfully loaded");
 
         manifests.sort_by_key(|m| m.id);
         Ok(manifests)
@@ -275,7 +282,9 @@ impl ManifestStore {
     pub(crate) async fn read_latest_manifest(
         &self,
     ) -> Result<Option<(u64, Manifest)>, SlateDBError> {
+        debug!("entering read_latest_manifest");
         let manifest_metadatas_list = self.list_manifests(..).await?;
+        debug!("successfully read the manifest_metadatas_list");
         match manifest_metadatas_list.last() {
             None => Ok(None),
             Some(metadata) => Ok(self.read_manifest(metadata.id).await?),
-- 
2.39.3 (Apple Git-146)

